---
title: "Modul 1: StatelessWidget dan StatefulWidget"
description: "Belajar StatelessWidget dan StatefulWidget."
---

import { CodeBlock } from "/src/components/CodeBlock";
import { MockupWindowCode } from "/src/components/MockupWindowCode";

---

**VERSI** 1.0

AGUSTUS 2025

---

# _MODUL 1 - Materi_

# _StatelessWidget dan StatefulWidget_

**DISUSUN OLEH**:

- Ali Sofyan Kholimi, M.Kom.
- Faizal Qadri Trianto
- Muhammad Hisyam Kamil

---

# PENDAHULUAN

## _TUJUAN_

1.  Membedakan konsep, siklus hidup (lifecycle), dan kegunaan antara StatelessWidget dan StatefulWidget.
2.  Menganalisis dampak dari kedua jenis widget tersebut terhadap proses rendering atau penggambaran ulang antarmuka (UI).

## _TARGET MODUL_

1.  Mahasiswa berhasil membangun dua aplikasi sederhana dengan pendekatan StatelessWidget dan StatefulWidget.
2.  Mahasiswa mampu membandingkan struktur kode, performa, serta memilih jenis widget yang paling tepat untuk sebuah kasus pengembangan.

## _PERSIAPAN_

1.  Emulator Android atau perangkat fisik yang terhubung dan aktif.
2.  Tools sederhana seperti Stopwatch atau pemahaman dasar tentang Flutter DevTools untuk melakukan analisis performa.

## _KEYWORDS_

widget, render tree, rebuild, UI statik, UI dinamis, state

## _TABLE OF CONTENTS_

1.  [**PENDAHULUAN**](#pendahuluan)
    - [TUJUAN](#tujuan)
    - [TARGET MODUL](#target-modul)
    - [PERSIAPAN](#persiapan)
    - [KEYWORDS](#keywords)
    - [TABLE OF CONTENTS](#table-of-contents)
2.  [**KONSEP DASAR FLUTTER WIDGET TREE**](#konsep-dasar-flutter-widget-tree)
    - [Arsitektur UI Flutter Berbasis Widget](#arsitektur-ui-flutter-berbasis-widget)
    - [Widget Tree: Struktur Hierarkis dalam Flutter](#widget-tree-struktur-hierarkis-dalam-flutter)
    - [Mengapa Flutter Menggunakan Widget Tree?](#mengapa-flutter-menggunakan-widget-tree)
    - [Stateless vs Stateful: Dua Jenis Widget Utama](#stateless-vs-stateful-dua-jenis-widget-utama)
    - [Perbedaan Antara StatelessWidget dan StatefulWidget](#perbedaan-antara-statelesswidget-dan-statefulwidget)
    - [Rekap Materi](#rekap-materi)
3.  [**PENGENALAN PADA LAYOUT UI FLUTTER**](#pengenalan-pada-layout-ui-flutter)
    - [Peran Widget Layout dalam Flutter](#peran-widget-layout-dalam-flutter)
    - [Widget Layout Dasar](#widget-layout-dasar)
    - [Latihan Membuat Layout Statis](#latihan-membuat-layout-statis)
    - [Rekap Materi](#rekap-materi-1)
4.  [**STATE MANAGEMENT PADA FLUTTER: setState vs External State**](#state-management-pada-flutter-setstate-vs-external-state)
    - [Pendahuluan setState() dan Batasannya](#pendahuluan-setstate-dan-batasannya)
    - [Konteks untuk State yang Lebih Kompleks](#konteks-untuk-state-yang-lebih-kompleks)
    - [Pengenalan Provider sebagai Solusi](#pengenalan-provider-sebagai-solusi)

    - [Rekap Materi](#rekap-materi-3)

5.  [**PROFILING SEDERHANA**](#profiling-sederhana)
    - [Mengapa Profiling Penting?](#mengapa-profiling-penting)
    - [Memanfaatkan debugPrint()](#memanfaatkan-debugprint)
    - [Hot Reload vs Hot Restart](#hot-reload-vs-hot-restart)
    - [Pengenalan Flutter DevTools](#pengenalan-flutter-devtools)
    - [Rekap Materi](#rekap-materi-4)
6.  [**CODELAB**](#codelab)
    - [Tugas](#tugas)
    - [Instruksi](#instruksi)

---

# KONSEP DASAR FLUTTER WIDGET TREE

## _Arsitektur UI Flutter Berbasis Widget_

Flutter adalah framework yang dirancang untuk membangun aplikasi dengan antarmuka pengguna (UI) yang modern, responsif, dan fleksibel. Salah satu pendekatan unik yang membuat Flutter berbeda dari framework lainnya adalah konsepnya yang berbasis widget. Dalam Flutter, setiap elemen yang Anda lihat di layar, baik itu teks, tombol, gambar, atau struktur tata letak, semuanya adalah **widget**. Widget ini menjadi blok bangunan utama dalam Flutter, yang digunakan untuk menyusun dan merancang UI aplikasi.

Flutter mengorganisasikan widget dalam sebuah struktur hierarkis yang disebut **Widget Tree**. Widget Tree adalah representasi visual dan logis dari hubungan antar widget dalam aplikasi. Struktur ini menggambarkan bagaimana widget "induk" (parent) berinteraksi dengan widget "anak" (child), membentuk sebuah hierarki yang menyerupai pohon. Sebagai contoh, sebuah layar aplikasi mungkin memiliki widget induk berupa `Column`, yang di dalamnya terdapat widget `Text` untuk menampilkan judul, widget `Row` untuk menyusun tombol-tombol secara horizontal, dan widget `Image` untuk menampilkan gambar. Semua elemen ini tersusun dalam Widget Tree.

## _Widget Tree: Struktur Hierarkis dalam Flutter_

Widget Tree dapat dibayangkan seperti pohon keluarga. Widget induk bertindak sebagai "orang tua" yang dapat memiliki satu atau lebih widget anak sebagai "anak-anaknya". Widget anak juga dapat menjadi induk bagi widget lainnya, menciptakan hubungan hierarkis yang kompleks dan terstruktur. Struktur ini tidak hanya menggambarkan bagaimana elemen UI disusun, tetapi juga menjadi cetak biru untuk proses rendering di layar.

Sebagai contoh, jika Anda ingin membuat sebuah aplikasi sederhana yang memiliki teks dan dua tombol yang disusun secara horizontal, Anda dapat menggunakan struktur Widget Tree seperti ini:

import main from "./code/main.dart?raw";

<CodeBlock
  desc="main.dart"
  language="dart"
  code={`
${main}`}
/>

Pada kode ini, aplikasi dimulai dengan root widget `MaterialApp`, yang membungkus seluruh aplikasi. Di dalamnya, terdapat widget `Scaffold` yang menyediakan struktur dasar layar, termasuk `AppBar` untuk menampilkan judul aplikasi, dan `body` untuk menampilkan konten utama. Konten utama terdiri dari widget `Column` sebagai induk, yang menyusun elemen secara vertikal. Di dalam `Column`, terdapat widget `Text` untuk menampilkan teks "Parent Widget", serta widget `Row` yang menyusun dua teks anak secara horizontal.

Jika kita menggambarkan struktur Widget Tree dari kode di atas, hasilnya akan terlihat seperti ini:

import ImgWidgetTree from "./media/widget-tree.png?jsx";

<ImgWidgetTree alt="Widget Tree" />

## _Mengapa Flutter Menggunakan Widget Tree?_

Pendekatan berbasis Widget Tree memberikan fleksibilitas yang luar biasa bagi pengembang untuk menyusun elemen UI sesuai kebutuhan. Dengan struktur hierarkis ini, Flutter mampu menangani elemen UI dari desain sederhana hingga kompleks dengan cara yang konsisten. Tidak ada perbedaan antara elemen visual seperti teks atau tombol dan elemen tata letak seperti kolom atau baris; semuanya adalah widget. Selain itu, struktur ini memungkinkan Flutter untuk hanya menggambar ulang bagian dari Widget Tree yang berubah, bukan seluruh tree, sehingga aplikasi menjadi lebih efisien dan responsif.

Misalnya, jika dalam aplikasi di atas Anda mengubah teks pada Child Widget 1, Flutter hanya akan menggambar ulang widget tersebut tanpa memengaruhi widget lainnya seperti `AppBar` atau `Parent Widget`. Proses ini disebut **rebuild**, dan inilah yang membuat Flutter sangat hemat sumber daya.

## _Stateless vs Stateful: Dua Jenis Widget Utama_

Dalam Flutter, widget dibagi menjadi dua kategori utama berdasarkan kemampuannya untuk menangani perubahan data: **StatelessWidget** dan **StatefulWidget**. Kedua jenis widget ini memiliki peran yang berbeda, tergantung pada kebutuhan aplikasi Anda.

1.  **StatelessWidget**

    `StatelessWidget` adalah widget yang tidak memiliki state atau data internal yang dapat berubah. Properti dari widget ini bersifat tetap (immutable) dan ditentukan saat widget pertama kali dibuat. Setelah itu, widget ini tidak akan pernah berubah selama siklus hidupnya. `StatelessWidget` cocok untuk elemen UI yang statis, seperti judul halaman, ikon, atau teks deskripsi.

    Sebagai contoh, berikut adalah implementasi sederhana dari `StatelessWidget`:

import mystatelesswidget from "./code/mystatelesswidget.dart?raw";

    <CodeBlock desc="mystatelesswidget.dart" language="dart" code={mystatelesswidget} />

    Pada contoh di atas, teks yang ditampilkan oleh widget bersifat tetap. Tidak peduli berapa kali aplikasi dijalankan, teks tersebut tidak akan berubah. `StatelessWidget` sangat ringan dan efisien karena tidak memiliki mekanisme untuk memperbarui UI berdasarkan perubahan data.

2.  **StatefulWidget**

    Berbeda dengan `StatelessWidget`, `StatefulWidget` adalah widget yang memiliki state atau data internal yang dapat berubah selama aplikasi berjalan. **State** adalah informasi yang dapat memengaruhi bagaimana widget dirender di layar. `StatefulWidget` terdiri dari dua bagian utama: `StatefulWidget` itu sendiri, yang bersifat tetap, dan `State`, yang bersifat dinamis.

    `StatefulWidget` cocok untuk elemen UI yang dinamis atau interaktif, seperti tombol yang dapat ditekan, slider, atau data yang diambil dari API. Berikut adalah contoh sederhana dari `StatefulWidget`:

import mystatefulwidget from "./code/mystatefulwidget.dart?raw";

    <CodeBlock desc="mystatefulwidget.dart" language="dart" code={mystatefulwidget} />

    Pada contoh ini, variabel **counter** adalah state yang menyimpan data angka. Fungsi `incrementCounter()` memanggil `setState()` untuk memberi tahu Flutter bahwa ada perubahan pada state, sehingga UI perlu digambar ulang. Ketika tombol ditekan, angka pada layar akan bertambah, mencerminkan perubahan pada state.

## _Perbedaan Antara StatelessWidget dan StatefulWidget_

`StatelessWidget` lebih sederhana dan efisien karena tidak melibatkan logika pembaruan UI. Namun, widget ini tidak cocok untuk elemen UI yang memerlukan interaksi pengguna atau perubahan data. Sebaliknya, `StatefulWidget` lebih fleksibel karena dapat menangani perubahan data dan interaksi pengguna, tetapi lebih kompleks dan membutuhkan lebih banyak sumber daya.

| Aspek               | StatelessWidget                    | StatefulWidget                           |
| :------------------ | :--------------------------------- | :--------------------------------------- |
| **Kemampuan State** | Tidak memiliki state               | Memiliki state                           |
| **Perubahan UI**    | Tidak dapat berubah setelah dibuat | Dapat berubah sesuai dengan state        |
| **Kinerja**         | Lebih ringan dan cepat             | Lebih berat karena sering digambar ulang |
| **Kegunaan**        | Elemen UI statis                   | Elemen UI dinamis dan interaktif         |

Dengan memahami perbedaan antara `StatelessWidget` dan `StatefulWidget`, Anda dapat memilih jenis widget yang paling sesuai dengan kebutuhan aplikasi Anda. Struktur hierarkis Widget Tree dan kemampuan untuk menangani state inilah yang membuat Flutter menjadi framework yang sangat fleksibel dan efisien untuk membangun antarmuka pengguna modern.

## _Rekap Materi_

Bab ini memperkenalkan konsep dasar Flutter Widget Tree, yang menjadi fondasi untuk menyusun dan merender elemen UI dalam aplikasi. Widget Tree adalah struktur hierarkis yang memungkinkan Flutter untuk menangani elemen UI dengan cara yang fleksibel dan efisien. Selain itu, kita juga telah memahami perbedaan antara `StatelessWidget` dan `StatefulWidget`, yang merupakan dua jenis widget utama dalam Flutter. Dengan memahami konsep ini, Anda dapat mulai merancang aplikasi yang responsif dan sesuai kebutuhan.

Pada bab berikutnya, kita akan melanjutkan dengan pembahasan tentang layout UI Flutter, termasuk bagaimana widget tata letak seperti `Column`, `Row`, dan `Container` digunakan untuk menyusun elemen UI secara terstruktur.

---

# PENGENALAN PADA LAYOUT UI FLUTTER

Setelah memahami konsep dasar Flutter yang berbasis widget, langkah berikutnya adalah mempelajari bagaimana widget-widget ini dapat disusun untuk membentuk antarmuka pengguna yang terstruktur, estetis, dan fungsional. Dalam Flutter, elemen-elemen UI tidak hanya berdiri sendiri, tetapi saling terhubung dan disusun dalam tata letak tertentu. Di sinilah **widget layout** memainkan peran penting.

Widget layout adalah jenis widget khusus yang dirancang untuk mengatur posisi, ukuran, dan tata letak widget lain di dalamnya. Widget ini memungkinkan pengembang untuk menyusun elemen UI sesuai kebutuhan, baik itu secara vertikal, horizontal, atau dalam bentuk grid. Dengan menggunakan widget layout, Anda dapat menciptakan struktur visual yang rapi dan mudah dipahami oleh pengguna.

## _Peran Widget Layout dalam Flutter_

Widget layout adalah fondasi utama untuk membangun struktur visual aplikasi. Dalam Flutter, widget layout memberikan fleksibilitas tinggi untuk menyusun elemen UI. Anda dapat menentukan bagaimana widget-widget ditampilkan di layar, misalnya:

- Apakah widget ditampilkan secara vertikal atau horizontal.
- Bagaimana posisi widget diatur di sepanjang sumbu utama dan sumbu sekunder.
- Bagaimana ruang kosong di sekitar widget ditangani, seperti margin atau padding.

Dengan widget layout, Anda dapat menciptakan tata letak yang responsif dan adaptif, yang mampu menyesuaikan diri dengan berbagai ukuran layar, mulai dari ponsel hingga tablet.

## _Widget Layout Dasar_

Flutter menyediakan berbagai jenis widget layout yang dirancang untuk menyusun elemen UI dengan cara yang spesifik. Berikut adalah beberapa widget layout dasar yang paling sering digunakan:

1.  **Column**

    Widget `Column` digunakan untuk menyusun widget-widget anaknya secara vertikal, dari atas ke bawah. Ini adalah pilihan yang tepat ketika Anda ingin menyusun elemen UI dalam satu kolom, seperti daftar atau form.

    **Properti Utama pada Column:**
    - `mainAxisAlignment`: Properti ini mengatur posisi widget di sepanjang sumbu utama, yaitu sumbu vertikal. Anda dapat menentukan apakah widget harus dimulai dari atas, tengah, atau bawah.
    - `crossAxisAlignment`: Properti ini mengatur posisi widget di sepanjang sumbu sekunder, yaitu sumbu horizontal. Anda dapat menentukan apakah widget harus sejajar ke kiri, tengah, atau kanan.

    Berikut adalah contoh penggunaan `Column`:

import mycolumn from "./code/column.dart?raw";

    <CodeBlock desc="column.dart" language="dart" code={mycolumn} />

    Pada contoh di atas, widget `Column` menyusun tiga teks secara vertikal. Properti `mainAxisAlignment` diatur ke `center`, sehingga teks-teks tersebut ditampilkan di tengah layar secara vertikal. Properti `crossAxisAlignment` diatur ke `start`, sehingga teks-teks tersebut sejajar ke kiri secara horizontal.

2.  **Row**

    Widget `Row` digunakan untuk menyusun widget-widget anaknya secara horizontal, dari kiri ke kanan. Ini adalah pilihan yang tepat ketika Anda ingin menyusun elemen UI dalam satu baris, seperti tombol navigasi atau ikon.

    **Properti Utama pada Row:**
    - `mainAxisAlignment`: Properti ini mengatur posisi widget di sepanjang sumbu utama, yaitu sumbu horizontal. Anda dapat menentukan apakah widget harus dimulai dari kiri, tengah, atau kanan.
    - `crossAxisAlignment`: Properti ini mengatur posisi widget di sepanjang sumbu sekunder, yaitu sumbu vertikal. Anda dapat menentukan apakah widget harus sejajar ke atas, tengah, atau bawah.

    Berikut adalah contoh penggunaan `Row`:

import myrow from "./code/row.dart?raw";

    <CodeBlock desc="row.dart" language="dart" code={myrow} />

    Pada contoh di atas, widget `Row` menyusun tiga teks secara horizontal. Properti `mainAxisAlignment` diatur ke `spaceAround`, sehingga teks-teks tersebut memiliki jarak yang sama di antara mereka. Properti `crossAxisAlignment` diatur ke `center`, sehingga teks-teks tersebut sejajar di tengah secara vertikal.

3.  **Container**

    Widget `Container` adalah "kotak serbaguna" yang dapat digunakan untuk membungkus widget lain dengan properti tambahan. `Container` memungkinkan Anda untuk menyesuaikan elemen UI dengan warna latar belakang, ukuran, dekorasi, margin, dan padding.

    **Properti Utama pada Container:**
    - `color`: Memberikan warna latar belakang pada container.
    - `width` dan `height`: Mengatur ukuran container.
    - `decoration`: Menambahkan dekorasi seperti bingkai atau bayangan.

    Berikut adalah contoh penggunaan `Container`:

import mycontainer from "./code/container.dart?raw";

    <CodeBlock desc="container.dart" language="dart" code={mycontainer} />

    Pada contoh di atas, widget `Container` memiliki warna latar belakang biru, ukuran lebar 200 piksel, dan tinggi 100 piksel. Di dalamnya terdapat teks yang ditampilkan di tengah dengan warna putih.

4.  **Padding**

    Widget `Padding` digunakan untuk memberikan ruang kosong di sekeliling widget anaknya. `Padding` sangat berguna untuk mengatur jarak antar elemen UI agar terlihat lebih rapi dan terstruktur.

    **Properti Utama pada Padding:**
    - `padding`: Properti ini mengatur jumlah ruang kosong di setiap sisi (atas, bawah, kiri, kanan).

    Berikut adalah contoh penggunaan `Padding`:

import mypadding from "./code/padding.dart?raw";

    <CodeBlock desc="padding.dart" language="dart" code={mypadding} />

    Pada contoh di atas, widget `Padding` memberikan ruang kosong sebesar 20 piksel di semua sisi teks. Hal ini membuat teks terlihat lebih terpisah dari tepi layar.

## _Latihan Membuat Layout Statis_

Setelah memahami widget layout dasar, Anda dapat mempraktikkan cara menyusun elemen UI menggunakan `StatelessWidget`. Latihan ini bertujuan untuk membiasakan diri dengan penggunaan widget layout seperti `Column`, `Row`, dan `Container`, serta menciptakan antarmuka visual yang terstruktur dan estetis.

Berikut adalah contoh latihan untuk membuat tata letak sederhana dengan kombinasi `Column` dan `Row`:

import mylayout from "./code/column-row.dart?raw";

    <CodeBlock desc="column-row.dart" language="dart" code={mylayout} />

Pada latihan ini, Anda menggunakan kombinasi `Column`, `Row`, `Container`, dan `Padding` untuk membuat tata letak yang terdiri dari header, dua kotak sejajar, dan footer dengan padding.

## _Rekap Materi_

Bab ini memperkenalkan peran penting widget layout dalam Flutter, yang memungkinkan pengembang untuk menyusun elemen UI dengan cara yang fleksibel dan terstruktur. Dengan memahami widget layout dasar seperti `Column`, `Row`, `Container`, dan `Padding`, Anda dapat mulai membangun antarmuka pengguna yang estetis dan responsif. Pada bab berikutnya, kita akan membahas tentang Pengelolaan State dalam Flutter, termasuk bagaimana perubahan data memengaruhi UI.

**Referensi:** [_FLUTTER-LAYOUT-BASICS_](https://docs.flutter.dev/ui/layout)

---

# STATE MANAGEMENT PADA FLUTTER: setState vs External State

Flutter dikenal sebagai framework yang sangat fleksibel untuk membangun antarmuka pengguna yang interaktif dan responsif. Salah satu aspek penting dalam membangun UI dinamis adalah **state management**, yaitu cara data dikelola sehingga dapat memengaruhi tampilan dan perilaku sebuah widget. **State** adalah informasi yang menentukan bagaimana suatu widget terlihat atau berperilaku pada waktu tertentu. Ketika state berubah, UI perlu diperbarui agar mencerminkan perubahan tersebut.

Pertanyaan mendasar dalam state management adalah: Bagaimana cara memberitahu Flutter bahwa ada data yang berubah dan UI perlu diperbarui? Jawabannya tergantung pada pendekatan yang Anda gunakan, baik itu `setState()` untuk state lokal atau metode external state management seperti `Provider` untuk state global.

## _Pendahuluan setState() dan Batasannya_

Dalam Flutter, `setState()` adalah cara paling sederhana untuk mengelola state di dalam sebuah `StatefulWidget`. Ketika Anda memanggil `setState()`, Anda memberi tahu Flutter bahwa ada data yang berubah, dan bagian UI yang bergantung pada data tersebut perlu digambar ulang. Ini adalah pendekatan yang intuitif dan cocok untuk mengelola **state lokal**, yaitu state yang hanya relevan untuk satu widget tertentu.

1.  **Keunggulan setState()**
    - **Sederhana dan mudah dipahami:** Anda hanya perlu memanggil `setState()` di dalam widget yang membutuhkan pembaruan UI.
    - **Cocok untuk state lokal:** Jika data hanya digunakan oleh satu widget, `setState()` adalah solusi yang efisien.

    Berikut adalah contoh penggunaan sederhana `setState()`:

import setstate from "./code/setstate.dart?raw";

    <CodeBlock desc="setstate.dart" language="dart" code={setstate} />

    Pada contoh di atas, setiap kali tombol ditekan, nilai `counter` akan bertambah, dan UI akan diperbarui untuk mencerminkan perubahan tersebut. Fungsi `setState()` memberi tahu Flutter untuk menggambar ulang bagian UI yang bergantung pada variabel `counter`.

2.  **Batasan setState()**

    Meskipun `setState()` sangat berguna untuk state lokal, metode ini memiliki beberapa keterbatasan ketika digunakan dalam aplikasi yang lebih kompleks:
    - **Tidak scalable:** Ketika state perlu dibagikan ke banyak widget, `setState()` menjadi tidak efisien. Anda harus mengoper data dari satu widget ke widget lainnya secara manual, yang dapat membuat kode menjadi berantakan.
    - **Menyulitkan pengelolaan state global:** Dalam aplikasi besar dengan banyak halaman, mengelola state menggunakan `setState()` menjadi sangat sulit karena Anda harus melacak aliran data di seluruh aplikasi.

    Bayangkan sebuah aplikasi e-commerce. Data seperti status login pengguna atau isi keranjang belanja harus digunakan oleh banyak halaman sekaligus, seperti halaman utama, halaman profil, dan halaman checkout. Menggunakan `setState()` untuk mengelola data seperti ini akan sangat merepotkan karena Anda harus terus mengoper data antar widget secara manual.

## _Konteks untuk State yang Lebih Kompleks_

Ketika aplikasi menjadi lebih besar dan kompleks, kebutuhan untuk mengelola **state global** menjadi semakin penting. State global adalah state yang dibutuhkan oleh banyak widget di berbagai bagian aplikasi. Contohnya:

- **Status login pengguna:** Dibutuhkan oleh halaman utama, halaman profil, dan halaman pengaturan.
- **Isi keranjang belanja:** Dibutuhkan oleh halaman utama, halaman produk, dan halaman checkout.

Menggunakan `setState()` untuk mengelola state global seperti ini akan menghasilkan kode yang sulit dipelihara. Anda harus mengoper data dari satu widget ke widget lainnya secara manual, yang meningkatkan risiko kesalahan dan mengurangi efisiensi pengembangan.

## _Pengenalan Provider sebagai Solusi_

Untuk mengatasi masalah ini, komunitas Flutter mengembangkan berbagai pola state management yang lebih canggih. Salah satu yang paling populer adalah **Provider**. Provider adalah sebuah paket Flutter yang memungkinkan Anda untuk "menyediakan" state di puncak widget tree, sehingga widget mana pun di bawahnya dapat:

- Mendengarkan perubahan pada state tersebut.
- Menggunakan state tersebut tanpa perlu operan manual antar widget.

**Keunggulan Provider:**

1.  **Scalable:** Cocok untuk aplikasi besar dengan banyak halaman.
2.  **Efisien:** Mengurangi kompleksitas pengelolaan state global.
3.  **Reactive:** UI akan diperbarui secara otomatis ketika state berubah.

**Contoh Penggunaan Provider**

Berikut adalah langkah-langkah untuk menggunakan `Provider` dalam aplikasi Flutter:

1.  **Tambahkan dependensi Provider**

    Pertama, tambahkan dependensi Provider di file `pubspec.yaml`: 2. **Definisikan State**

    Buat kelas untuk mengelola state. Kelas ini harus menggunakan `ChangeNotifier` agar dapat didengarkan oleh widget lain:

import counterstate from "./code/counterstate.dart?raw";

    <CodeBlock desc="counterstate.dart" language="dart" code={counterstate} />

2.  **Gunakan Provider di Widget Tree**

    Bungkus aplikasi Anda dengan `ChangeNotifierProvider` untuk menyediakan state:

import changenotifierprovider from "./code/changenotifierprovider.dart?raw";

    <CodeBlock desc="changenotifierprovider.dart" language="dart" code={changenotifierprovider} />

3.  **Akses dan Gunakan State**

    Gunakan `Consumer` atau `Provider.of` untuk membaca dan memperbarui state:

import counterapp from "./code/counterapp.dart?raw";

    <CodeBlock desc="counterapp.dart" language="dart" code={counterapp} />

## _Rekap Materi_

Bab ini menjelaskan dua pendekatan utama dalam state management pada Flutter: `setState()` untuk state lokal dan `Provider` untuk state global. `setState()` adalah solusi sederhana yang cocok untuk aplikasi kecil atau state yang hanya relevan untuk satu widget. Namun, ketika aplikasi menjadi lebih besar dan kompleks, `Provider` menawarkan solusi yang lebih efisien dan scalable. Dengan memahami kedua pendekatan ini, Anda dapat memilih metode yang paling sesuai untuk kebutuhan aplikasi Anda.

**Referensi:** [_FLUTTER-STATE-MANAGEMENT-OVERVIEW_](https://docs.flutter.dev/data-and-backend/state-mgmt)

---

# IMPLEMENTASI APLIKASI SEDERHANA

Pada bab ini, kita akan mempraktikkan konsep `StatelessWidget` dan `StatefulWidget` dengan membuat aplikasi sederhana berupa counter. Aplikasi ini akan menunjukkan perbedaan mendasar antara kedua jenis widget tersebut, terutama dalam hal pengelolaan state dan pembaruan UI.

## _Versi Stateless: Memahami Keterbatasan_

Langkah pertama adalah membuat aplikasi counter menggunakan `StatelessWidget`. `StatelessWidget` adalah widget yang tidak memiliki state internal. Artinya, UI yang dihasilkan oleh widget ini bersifat statis dan tidak dapat berubah berdasarkan interaksi pengguna atau perubahan data.

**Counter dengan StatelessWidget:**

import counter_statelesswidget from "./code/counter-statelesswidget.dart?raw";

    <CodeBlock desc="counter-statelesswidget.dart" language="dart" code={counter_statelesswidget} />

**Hasil:**

- Angka counter di layar tidak berubah meskipun tombol ditekan.
- Hal ini terjadi karena `StatelessWidget` tidak memiliki mekanisme untuk menyimpan perubahan data atau memperbarui UI. Variabel `counter` hanya diperbarui di dalam memori, tetapi UI tidak digambar ulang untuk mencerminkan perubahan tersebut.

## _Versi Stateful: Menghidupkan Interaksi_

Langkah berikutnya adalah mengubah aplikasi counter menjadi `StatefulWidget`. `StatefulWidget` memiliki state internal yang memungkinkan Anda untuk menyimpan perubahan data dan memperbarui UI menggunakan fungsi `setState()`.

**Counter dengan StatefulWidget:**

import counter_statefulwidget from "./code/counter-statefulwidget.dart?raw";

    <CodeBlock desc="counter-statefulwidget.dart" language="dart" code={counter_statefulwidget} />

**Hasil:**

- Angka counter di layar tidak berubah meskipun tombol ditekan.
- Hal ini terjadi karena `StatelessWidget` tidak memiliki mekanisme untuk menyimpan perubahan data atau memperbarui UI. Variabel `counter` hanya diperbarui di dalam memori, tetapi UI tidak digambar ulang untuk mencerminkan perubahan tersebut.

**Perbandingan Antara Stateless dan Stateful**

| Aspek                 | StatelessWidget                 | StatefulWidget                           |
| :-------------------- | :------------------------------ | :--------------------------------------- |
| **Pembaruan UI**      | Tidak dapat memperbarui UI      | Dapat memperbarui UI dengan `setState()` |
| **Cocok untuk**       | UI statis atau tidak interaktif | UI dinamis atau interaktif               |
| **Pengelolaan State** | Tidak memiliki state internal   | Memiliki state internal                  |

## _Rekap Materi_

Bab ini menunjukkan perbedaan mendasar antara `StatelessWidget` dan `StatefulWidget` melalui implementasi aplikasi counter sederhana. `StatelessWidget` cocok untuk UI yang statis, sedangkan `StatefulWidget` memungkinkan Anda untuk membuat UI yang dinamis dan interaktif. Dengan memahami perbedaan ini, Anda dapat memilih jenis widget yang tepat untuk kebutuhan aplikasi Anda.

**Referensi:** [_WRITE-YOUR-FIRST-FLUTTER-APP_](https://docs.flutter.dev/get-started/codelab)

---

# PROFILING SEDERHANA

## _Mengapa Profiling Penting?_

Dalam pengembangan aplikasi Flutter, efisiensi adalah kunci untuk memastikan aplikasi berjalan dengan mulus dan responsif. Salah satu aspek penting dalam efisiensi adalah meminimalkan **rebuild** widget yang tidak perlu. Rebuild yang berlebihan dapat menyebabkan aplikasi menjadi lambat dan tidak responsif.

**Profiling** adalah proses melacak dan menganalisis performa aplikasi untuk mengidentifikasi potensi masalah, seperti rebuild yang tidak perlu atau penggunaan resource yang berlebihan. Melalui profiling, kita dapat memahami:

1.  Widget mana yang digambar ulang.
2.  Seberapa sering widget tersebut digambar ulang.
3.  Apakah ada optimasi yang diperlukan?

## _Memanfaatkan debugPrint()_

Cara paling sederhana untuk melacak rebuild widget adalah dengan menggunakan perintah `debugPrint()` di dalam metode `build()` sebuah widget. Setiap kali widget tersebut digambar ulang, pesan akan muncul di konsol. Ini membantu Anda melacak frekuensi dan waktu rebuild untuk widget tertentu.

**Contoh Implementasi: Profiling dengan debugPrint()**

import debugprint from "./code/debugprint.dart?raw";

    <CodeBlock desc="debugprint.dart" language="dart" code={debugprint} />

**Hasil:**

- Setiap kali widget `ProfilingWidget` digambar ulang, pesan "ProfilingWidget is rebuilding\!" akan muncul di konsol.
- Dengan cara ini, Anda dapat melacak frekuensi dan waktu rebuild untuk widget tertentu.

## _Hot Reload vs Hot Restart_

Dalam Flutter, ada dua cara utama untuk memuat ulang aplikasi saat Anda melakukan perubahan kode: **Hot Reload** dan **Hot Restart**. Keduanya memiliki fungsi yang berbeda dan cocok untuk kebutuhan yang berbeda.

**Hot Reload**

- Memuat ulang perubahan kode dengan cepat tanpa mereset state aplikasi.
- Cocok untuk perbaikan UI, seperti perubahan tata letak, warna, atau teks.
- Contoh Penggunaan: Mengubah warna latar belakang atau teks pada widget tanpa kehilangan data di aplikasi.

**Hot Restart**

- Memulai ulang seluruh aplikasi dan mereset semua state.
- Dibutuhkan jika ada perubahan pada logika state awal atau struktur aplikasi.
- Contoh Penggunaan: Mengubah definisi variabel global atau menambahkan state baru di aplikasi.

**Perbedaan Utama:**

| Aspek           | Hot Reload          | Hot Restart                         |
| :-------------- | :------------------ | :---------------------------------- |
| **Kecepatan**   | Sangat cepat        | Lebih lambat                        |
| **Reset State** | Tidak mereset state | Mereset seluruh state aplikasi      |
| **Cocok untuk** | Perubahan UI        | Perubahan logika atau struktur kode |

## _Pengenalan Flutter DevTools_

Untuk analisis performa yang lebih mendalam, Flutter menyediakan alat bernama **DevTools**. Flutter DevTools adalah alat berbasis web yang dirancang untuk membantu developer dalam profiling dan debugging aplikasi Flutter.

**Fitur Utama DevTools:**

1.  **Flutter Inspector:**
    - Memvisualisasikan widget tree aplikasi Anda.
    - Membantu memahami struktur aplikasi dan lokasi widget dalam hierarki.

2.  **Repaint Rainbow:**
    - Memberikan warna berbeda pada layer-layer widget setiap kali mereka digambar ulang.
    - Sangat membantu untuk mendeteksi rebuild yang tidak perlu.

**Cara Menggunakan Flutter DevTools**

1.  **Aktivasi DevTools**
    - Jalankan perintah berikut di terminal:

    <div class="bg-base-300">
      ```bash flutter pub global activate devtools ```
    </div>
    * Kemudian jalankan:
    <div class="bg-base-300">
      ```bash flutter pub global activate devtools ```
    </div>
    - Akses DevTools melalui browser.

2.  **Flutter Inspector**
    - Pilih tab `Flutter Inspector` untuk memvisualisasikan widget tree aplikasi Anda.
    - Anda dapat melihat hierarki widget dan memahami bagaimana widget saling berinteraksi.

3.  **Repaint Rainbow**
    - Aktifkan `Repaint Rainbow` melalui menu `Rendering` di DevTools.
    - Widget yang sering digambar ulang akan terlihat dengan warna yang terus berubah.

## _Rekap Materi_

Profiling adalah proses penting dalam pengembangan aplikasi Flutter untuk memastikan performa aplikasi tetap optimal. Dengan menggunakan alat sederhana seperti `debugPrint()`, Anda dapat melacak rebuild widget. Namun, untuk analisis yang lebih mendalam, Flutter DevTools menyediakan fitur seperti `Flutter Inspector` dan `Repaint Rainbow` yang sangat berguna.

**Referensi:** [_FLUTTER-DEVTOOLS_](https://docs.flutter.dev/tools/devtools)

---

# CODELAB

## _Tugas_

1.  Buat dua halaman Flutter: satu menggunakan `StatelessWidget` dan satu lagi menggunakan `StatefulWidget`.
2.  Pastikan kedua halaman menunjukkan perbedaan mendasar antara `StatelessWidget` dan `StatefulWidget` dalam pengelolaan state dan pembaruan UI.

## _Instruksi_

1.  **Gunakan kode berikut untuk menghasilkan data random:**

import random from "./code/random/main.dart?raw";

    <CodeBlock desc="random.dart" language="dart" code={random} />

2.  **Halaman StatelessWidget**
    - Tampilkan data random (string dan angka) yang hanya dihasilkan satu kali saat halaman pertama kali dibuka.
    - Data tidak berubah meskipun ada interaksi pengguna.

3.  **Halaman StatefulWidget**
    - Tampilkan data random (string dan angka).
    - Tambahkan tombol untuk menghasilkan ulang data random setiap kali tombol ditekan.

4.  **Bandingkan hasil kedua halaman. Jelaskan perbedaan dalam hal pengelolaan state dan pembaruan UI.**
